# OAuth
## Authentication
OAuth authentication is generally implemented as follows: 
1. The user chooses the option to log in with their social media account. The client application then uses the social media site's oAuth service to request access to some data that it can use to identify the user. This could be the email address that is registered with their account, for example.
2. After receiving an access token, the client application requests this data from the resource server, typically from a dedicated /userinfo ednpoint. 
3. Once it has received the data, the client application uses it in place of  username to log the user in. The access token that it received from the authorization servedr is often used instead of a traditional password. 
## How do vulnerabilities arise
OAuth authentication vulnerabilities arise partly because the OAuth specification is relatively vague and flexible by design. Although there are a handful of mandatory components requred for the basic functionality of each grant type, the vast majority of the implementation is completely optional. This includes many configuration settings that are necessary for keeping users' data secure. In short, there's plenty of opportunity for bad pracctice to creep in. One of the other key issues with OAAuth is the general lack of built-in security features. The security relies almost entirely on developers using the right combination of confighuration opotions and implementing their own additional security measures on top, such as robust input validation. As you've probably gathered, there's a lot to take in and this is quite easy to get wrong if you're inexperienced with OAuth. Depending on the grant type, highly sensitivge data is also sent via thhe browser, which present various opportunities for an attacker to intercept it. 

## Example Request
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

## Exploiting OAuth
### Vulnerabilities in the client application
#### Improper implementation of the implicit grant type
Due to the dangers introduced by sending access tokens via the browser, the implicit grant type is mainly recommended for single-page applications. However, it is also often used in classic client-server web applications because of its relative simplicity. 

In this flow, the access token is sent from the OAuth service to the client application via the user's browser as a URL fragment. The client application then accesses the token using JavaScript. The trouble is, if the application wants to maintain the session after the user closes the page, it needs to store the current user data (normally a user ID and the access token) somewhere.

To solve this problem, the client application will often submit this data to the server in a POST request and then assign the user a session cookies, effectively logging them in. This request is roughly equivalent to the form submission request that might be sent as part of a classic, password-based login. However, in this scenario, the server does not have any secrets or passwords to compare with the submitted data, which means that it is implicitly trusted. 

In the implicit flow, this POST request is exposed to attackers via their browser. As a result, this behaviour can lead to a serious vulnerability if the client application doesn't properly check that the access token matches the other data in the request. In this case, an attacker can simply change the parameters sent to the server to impersonate any user. 

#### Flawed CSRF protection
Although many components of the OAuth flows are optional, some of them are stongly recommended unless there's an iimportant reason not to use them. One such example is the state parameter. 

The state parameter should ideally contain an unguessable value, such as the hash of something ited to the user's session when it first initiates the OAuth flow. This value is then passed back and forth between the client application and the OAuth service as a form of CSRF token for the client application. Therefore, if you notice that the authorization requewst does not send a state parameter, this is extremely interesting from an attgacker's perspective. 

It potentially means that they can initiate an OAuth flow themselves before tricking a user's browser into completing it, similar to a traditional CSRF attack. This can haved secere consequences depending on how OAuth is being used by the client application. 

Consider a website that allows users to log in using either a classic, password-based mechanism or by linking their account to social media profile using OAuth. In thiis case, if the application fails to use the state parmeter, an attacker could potentiall hjijack a victim user's account on the client application by binding it to theirt own social media account. 

### Vulnerabilities in the OAuth service
#### Leaking authorization codes and access tokens
Perhaps the most infamous OAuth-baswed vulnerability is when the configuration of the Oauth service itself enables attackers to steal authorization codes or access tokens associated with other user's accounts. By stealing a valid code or token, the attacker may be able to access the victim's data. Ultimately, this can completely compromise their account - the attacker could potentially log in as the victim user on any client application that is registered with this OAuth service. 

Depending on the grant type, either a code or token is sent via the victimn's browser to the /callback endpoint specified in the redirect_uri parameter of the authorization request. If the OAuth service fails to validate thi9s URI properly, an attacker may be able to construct a CSRF-like attack, tricking the victim's browser into initiating an OAuth flow that will send the code or token to an attacker-controlled redirect_uri.  

In the case of the authorization code flow, an attacker can potentially steal the victim's code before it is used. They can then send this code to the client application's legitimate /callback endpoint (the original redirect_uri) to get access to the user's account. In this scenario, an attacker does not even need to know the client secret or the resulting access token. As long as the victim has a valid session with the OAuth service, the client application will simply complete the code/token exchange on the attacker's behalf before loggin them in to the victim's account. 

Note that using state or nonce protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser. 

#### Flawed scope validation
Due to the kins of attacks seen in the previous lab, it is best practice for client applications to provide a whitelist of their genuine callback URIs when registering with the OAuth service. This way, when the OAuth service receives a new request, it can validate the redirect_uri parameter against this whitelist. In this case, supplying an external URI will likely result in an error. However, there may still be ways to bypass this validation. 

When auditing an OAuth flow, you should try experimenting with the redirect_uri parameter to understand how it is being validated. For example: 

* Some implementations allow for a range of subdirectories by checking only that the string starts with the correct sequence of characters i.e. an approved domain. You should try removing or adding arbitrary paths, query parameters, and fragments to see what you can change without triggeringan error. 
* If you can append extra values to the default redirec t_uri parameter, you might be able to exxploit discrepancies between the parsing of the URI by the different components of the OAuth service. For example, you can try techniques such as: 

`https://default-host.com &@foo.evil-user.net#@bar.evil-user.net`

* You may occasionly come across server-side parameter pollution vulnerabilities. Just in case, you should try submitting duplicate redirect_uri parameters as follows: 

`https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net`

* Some servers also give special treatment to locachost URIs as they're often used during developmen. In some casesw,, any redirect URI beginning with localhost may be accidentally permitted in the production evironment. This could allow you to bypass the validation by registering a domain name such as localhost.evil-user.net.

It is important to note that you shouldn't limit your testing to just probing the redict_uri parameter in isolation. In the wild, you will often need to experiment with different combinations of changes to several parameters. Sometimes changing one parameter can afffect the validation of others. For example, changing the response_mode from query to fragment can sometimes completely alter the parsing of the redirect_uri, allowing you to submit URs that woulod otherwise be blocked. Likewise, if you notice that the web_messaage response mode is support, this often allows a wider range of subdomains in the redirect_uri. 

#### Stealing codes and access tokens via a proxy page
Against more robust targets, you might find that no matter what you try, you are unable to successfully submit an external domain as the redirect_uri. However, that doesn't mean it's time to give up. 

By this stage, you should have a relatively good understanding of which parts of the URI you can tamper with. The key now is to use this knowledge to try and access a wider attack surface within the client application itself. In other words, try to work out whether you can change the redirect_uri parameter to point to any other pages on a whitelisted domain. 

Try find ways that you can successfully access different subdomains or paths. For example, the default URi will often be on an OAuth-specific path, such as /oauth/callback, which is unlikely to have any interesting subdirectories. However, you may be able to use directory traversal tricks to supploy any arbitrary path on tthe domain. 

Something like this; 
`https://client-app.com/oauth/callback/../../example/path`
May be interpreted on the back-end as:
`https://client-app.com/example/path`

Once you identify which other pages you are able to set as the redirect URI, you should audit them for additional vulnerabilities that you can potentially use to leak the code or token. For the authorization code flow, yhou need to find a vulnerability that gives you access to the query parameters, whereas for the implicit garnt type, you need to extract the URL fragment. 

One of the most useful vulnerabilities for this purpose is an open redirect. You can use this as a proxy to forward victims, along with their code or token, to an attacker-controlled domain where you can host any malicious script you like. 

Note that for the implicit grant type, stealing an access token doesn't just enable you to log in to thee victim's account on the client appli9cation. As the entire implicit takes place via the browser, you can also use the token to make your own API calls to the OAuth service's resource server. This may enable you to fetch sensitive user data that you cannot normally access from the client application's web UI. 



  * Unverified user registration