# Authentication
## Vulnerabilities in password-based login
### Brute-forcing usernames
Usernames are especially easy to guess if they conform to a recognizable pattern, such as an email address. For example, it is very common to see business logins in the format firstname.lastname@somecompany.com However, even if there is no obvious patter, sometimes even high-privileged accounts are created using predictable usernames, such as admin or administrator. 

During auditing, check whether the website discloses potential usernames publicly. For example, are you able to access user profiles without logging in? Even if the actual content of the profiles is hidden, the name used in the addresses are disclosed. Occasionally, respones contain emails addresses of high-privileged user like administrators and IT support. 

### Brute-forcing passwords
Passswords can similarly be brute-forced, with the difficulty varying based on the strength of the password. Many websites adopt some form of password policy, which forces users to create high-entropy passwords that are, theoretically at least, harder to crack using brute-force alone. This typically involves enforcing passwords with: 

* A minimum number of characters
* A mixture of lowever and upper case letters
* At least one special character

HOwever, while high-entropy passwords are difficult for computers alone to crack, we can use a basic knowledge of human behaviour to exploit the vulnerabilities that users unwittingly introduce to this system. Rather than creating a strong password with a random combination of characters, users often take a password that they can remember and try to crowbar it itno fitting the password policy. For example, if mypassword is not allowed, users may try something like Mypassword1! or Myp4$$w0rd instead. 

In cases where the policy requires user to change their passwords on a regular basis, it is also common for users to just make minor, predictable changes to their preferred password. For example, Mypassword1! becomes Mypassword2? or Mypassword2!. 

This knowledge of likely credentials and predictable patterns means that brute-force attacks can often be much more sophisticated, and therefore effective,, than simply iterating through every possible combination of characters. 

### Username enumeration
Username enumeration is when a attacker is able to observe changes in the website's behaviour in order to identify whether a given username is valid. 

Username enumeratyion typically occurs either on the login page, for example,k when you enter a  valid username but an incorrect password, or on registration forms when you enter a username that is already taken. This greatly reduces the time and effort required to brute-forde a login beccause the attacker is able to quickly generate a shortlist of valid usernames. 

While attempting to brute-forcve a login page, you should pay particular attention to any differences in: 

* Status codes: During a brute-force attqaqack, the returned HTTP status code is likely to be the same for the vast majority of ghuesses because most of them will be wrong. If a guess returns a different status code, this is a strong indication that hte username was correct. It is bbest practice3 for websites to always return the same status code regardless of the outcome, but this practice is not always foillowed. 
* Error messages: Sometimes the returned error message is different depending on whether both the username AND password are incorrect or only the password was incorrect. It is best practice for websites to use identical generic messages in both cases, but small typing errors sometimes creep in. Just one character out of place makes the two messwages distict, even in cases where the characcter is not visible on the rendered page. 
* Response times: If most of the request were handled with a similar response time, any that deviate from this suggest that something different was happening behind the scenes. This is another indication that the guessed usertname might be correct. For example, a website might only check whether the passw9ord is correct if the username is valid. This extra step might cause a slight increase in the response time. This may be subtle, but an attacker can make this delay more obvious by entering an excessively long password that he website takes noticeable longer to handle. 

### Flawed brute-force protection
It is highly likely that a brute-force attack will involve many failed guesses before the attacker successfully compromises an account. Logically, brute-force protection revolves around trying to make it as tricky as possible to automate the process and slow down the rate at which an attacker can attempt logins. The two most common ways of preventing brute-force attacks are: 

* Locking the account that the remote user is trying to access if they make too many failed login attempts
* Blocking the remote user's IP address if they make too many login attempts in quick succession. 

Both approaches offer varying degress of protection, but neither is invulnerable, especially if implemented using flawed logic. 

For example, you might sometimes find that your IP is blocked if you fail to log in too many times. In some implementations, the counter for the number of failed attempts resets if the IP owner logs in successfully. This means an attacker would simply have to log in to their own account every few attempts to prevent this limit from ever being reached. 

In this case, merely including your own login credentials at regular intervals throughout the wordlist is enough to render this defense virtually useless. 

### Account Locking
One way in which websites try to prevent brute-forcing is to lock the account if certain suspicious criteria are met, usually a set number of failed login attempts. Just as with normal login errors, responses from the server indicating that an account is locked can also help an attacker to enumerate usernames. 

Locking an account offers a certain amount of protection against targeted brute-forcing of a specific account. However, this approach fails to adequately prevent brute-force attacks in which the attacker is just trying to gain access to any random account they can. 

For example, the following method can be used to work around this kind of protection: 

1. Establish a list of candidate usernames that are likely to be valid. This could be through username enumeration or simply based on a list of common usersnames. 
2. Decide on a very small shortlist of passwords that you think at least one user is likely to have. Curically, the number of passwords you select must not exceed the number of login attempts allowed. for example, if you have worked out that limit is 3 attempts, you need to picck a mximum of 3 password guesses. 
3. Using a tool such as Burp Intruder, try each of the selected passwords with each of the candidate usernames. This way, you can attempt to brute-force every account without triggering the account lock. You only need a single user to use one of the tree passwords in order to compromise an account. 

Account locking also fails to protect against credential stuffing attacks. This involves using a massive dictionary of username:password pairs, composed of genuine login credentials stolen in data breaches. Credential stuffing relies on the fact that many people reuse the same username and password on multiple websites and, therefore, there is a chance that some of the compromised credentials in the dictionary are also valid on the target website. Account locking does not protect against credential stuffing because each username is only being attempted once. Credential stuffing is particularly dangerous because it can sometimes result in the attacker compromising many different accounts with just a single automated attack. 




## Vulnerabilities in multi-factor authentication
## Vulnerabilities in other authentication mechanisms
## OAuth authentication
## How to secure authentication mechanisms