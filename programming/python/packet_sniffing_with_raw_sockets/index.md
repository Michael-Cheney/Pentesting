# Packet Sniffing with Raw Sockets
* Need root for raw sockets in python
## Raw Socket Basics
* Raw sockest provide a way to bypass the whole network stack travversal of a packet and deliver it directly to an application
* Multiple ways to create raw sockets. We will concentrate on the PF_PACKET interace
## PF_PACKET Interface
* It is a software interface to send/receive packest at layer 2 of the OSI i.e. device driver
* All packets received will be complete with all headers and data
* All packets sent will be transmitted without modification by the kernel to the medium
* Supports filtering using Berkley Packet Filter

## Creating Raw Sockets
* Use the socket module
* Read Packets
* Interpret and analyze them
* Can send out responses as well

## Extracting Binary Data into Variables
| Format | C Type | Python Type | Standard Size |
|--------|--------|-------------|---------------|
| x | pad byte | no value | |
| c | char | string of length 1 | 1 |
| b | signed char | integer | 1 |
| B | unsigned char | integer | 1 |
| ? | _Bool | bool | 1 |
| h | short | integer | 2 |
| H | unsigned short | integer | 2 |
| i | int | integer | 4 |
| I | unsigned int | integer | 4 |
| l | long | integer | 4 |
| L | unsigned long | integer | 4 |
| q | long long | integer | 8 | 
| Q | unsigned long long | integer | 8 |
| f | float | float | 4 |
| d | double | float | 8 |
| s | char[] | string | |
| p | char[] | string | |
| P | void * | integer | |

### Examples
```python
import struct
# Pack '1' as format B unsigned char, Output '\x01'
struct.pack("B", 1)
# Pack '1' as format H unsigned short, Output '\x01\x00'
struct.pack("H", 1)
# Pack '1' as format H unsigned short in Big Endian format, Output '\x00\x01'
struct.pack(">H", 1)
# Pack '1' as format H unsigned short in Big Endian format, Output '\x00\x01'
struct.pack("!H", 1)
# Pack '1' as format L unsigned long in Big Endian format, Output '\x00\x00\x00\x01'
struct.pack("!L", 1)
# Unpack '1' as format L unsigned long in Big Endian format, 
struct.unpack("!L", "\x00\x00\x00\x01")
```

## Packet Headers
### Ethernet Header 
* First 14 Bytes



## Example
```python
#!/usr/bin/env python

import socket
import struct
import binascii

# Create a raw socket 0x0800 = IP Protocol
# Find the hex addresses in /usr/include/linux/if_ether.h
rawSocket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
pkt = rawSocket.recvfrom(2048)
ethernetHeader = pkt[0][0:14]
# First 6 bytes is the destination MAC address, the next 6 is the source. The last 2 bytes is the ether type this converts to a tuple
eth_hdr = struct.unpack("!6s6s2s", ethernetHeader)
# Converts values to readable Hex
binascii.hexlify(eth_hdr[0])
binascii.hexlify(eth_hdr[1])
binascii.hexlify(eth_hdr[2])
# Packet 0, Bytes 14:34 are the IP Address header
ipHeader = pkt[0][14:34]
# Unpack the IP Header, First 12 bytes is miscellaneous header stuff. Then next 4 is the Source Address, Then next 4 is the Destination Address. Outputs as a tuple
ip_hdr = struct.unpack("!12s4s4s", ipHeader)

# NTOA is network to ascii
print "Source IP address: " + socket.inet_ntoa(ip_hdr[1])
print "Destination IP address: " + socket.inet_ntoa(ip_hdr[2])

# Initial part of the tcp header
tcpHeader = pkt[0][34:54]
# Unpack 2 source ports H,H then 16 is the TCP Header
tcp_hdr = struct.unpack("!HH16s", tcpHeader)
```

# Set interface in promiscius mode
`sudo ifconfig eth0 promisc`